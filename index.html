<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="theme-color" content="#202730">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="author" content="Marx Fernandes - TÃ³pico Web" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/tomorrow-night.min.css">
    <link rel="stylesheet" href="app.css">
    <link rel="icon" href="favicon.ico">
    <title>Wall</title>
  </head>
  <body>
    <div class="container-fluid">
      <h1 class="display-1">
        Coding Challenge
      </h1>
      <p>
        Draw a line in the middle of the wall that cuts the fewest number of bricks.
      </p>

      <div class="row">
        <div class="col-12 col-lg-6">
          <div class="mb-3">
            <label>Try it out (bidimensional matrix):</label>
            <textarea id="editor" class="form-control text-monospace" rows="10">[
  [1, 2, 2, 1],
  [3, 1, 2],
  [1, 3, 2],
  [2, 4],
  [3, 1, 2],
  [1, 3, 1, 1]
]
</textarea>
            <span class="text-muted">
              The sum of units in each row should have the same result.
            </span>
          </div>
        </div>
        <div class="col-12 col-lg-6">
          <div class="mb-3">
            <label id="result"></label>
            <div class="wall-responsive">
              <div id="wall" class="wall"></div>
            </div>
          </div>
        </div>
      </div>

      <h1 class="display-1">
        Timeline
      </h1>
      <p>
        A little of history. The logic I used to solve this challenge.
      </p>

      <ul class="nav nav-tabs">
        <li class="nav-item">
          <a href="#v1" class="nav-link active" data-toggle="tab">Version 1</a>
        </li>
        <li class="nav-item">
          <a href="#v2" class="nav-link" data-toggle="tab">Version 2</a>
        </li>
      </ul>

      <div id="code-versions" class="tab-content">
        <div id="v1" class="tab-pane active py-3">
          <p>
            Look to the wall...
            <ol>
              <li>Pick a row and take the first brick (A1).</li>
              <li>Then, go to the next row and take the first brick (B1).</li>
              <li>
                Now compare the size. Is it smaller than the brick size (A1)?
                <ul>
                  <li>
                    Yes: Take the next brick (B2) and sum to the size of the previous one (B1.size + B2.size).
                    Ask again (item 4).
                  </li>
                  <li>
                    No: Time to check for collision. Is the result size equal or greater?
                    <ul>
                      <li>
                        Equal: It means that you have NOT hit any other bricks on the row (B).
                      </li>
                      <li>
                        Higher: It means that you hit some brick on the row (B). Count.
                      </li>
                    </ul>
                  </li>
                </ul>
                <li>
                  Repeat this proccess until you visit all the bricks in row (A),
                  except the last one (you cannot cut the corners). Then, go to the next row.
                </li>
              </li>
              <li>
                Keep going until close the cycle, that is, when you compare all the rows with each other.
                In the end you will have the best result.
              </li>
            </ol>
          </p>
          <p>
            Conclusion: You code will look like a mess and the complexity is sad.
          </p>
          <pre><code class="hljs javascript">(function (challenge) {

  function cut(wall) {
    var count &#x3D; 0;
    var position &#x3D; 0;

    for (var currentRow &#x3D; 0; currentRow &lt; wall.length; currentRow++) {
      var currentSize &#x3D; 0;

      for (var currentBrick &#x3D; 0; currentBrick &lt; wall[currentRow].length - 1; currentBrick++) {
        var currentCount &#x3D; 0;

        currentSize +&#x3D; wall[currentRow][currentBrick];

        for (var nextRow &#x3D; 0; nextRow &lt; wall.length; nextRow++) {
          if (nextRow &#x3D;&#x3D;&#x3D; currentRow) continue;

          var nextSize &#x3D; 0;

          for (var nextBrick &#x3D; 0; nextSize &lt; currentSize; nextBrick++) {
            nextSize +&#x3D; wall[nextRow][nextBrick];
          }

          if (nextSize &gt; currentSize) {
            currentCount++;
          }
        }

        if (currentCount &lt; count || count &#x3D;&#x3D;&#x3D; 0) {
          count &#x3D; currentCount;
          position &#x3D; currentSize;
        }
      }
    }

    return {
      count: count,
      position: position
    }
  }

  challenge.v1 &#x3D; {
    cut: cut
  };

})((window.challenge &#x3D; window.challenge || {}));
</code></pre>
        </div>
        <div id="v2" class="tab-pane py-3">
          <p>
            It can be better and simple. Look to the wall again...
            <ol>
              <li>Instead of seeing the bricks, look for the spaces between the bricks. The more the better.</li>
              <li>
                Visit each row and as you do this:
                <ul>
                  <li>Save the position of each space (sum the brick sizes).</li>
                  <li>Count the number of spaces in that position.</li>
                  <li>Whenever there are more spaces, save the current position.</li>
                </ul>
              </li>
              <li>When you complete the cycle, you will have the best result.</li>
            </ol>
          </p>
          <p>
            Conclusion: Much better than version 1. Cleaner and faster.
          </p>
          <pre><code class="hljs javascript">(function (challenge) {

  function cut(wall) {
    var spaceCount &#x3D; [];
    var spacePosition &#x3D; [];
    var cutPosition &#x3D; null;

    for (var currentRow &#x3D; 0; currentRow &lt; wall.length; currentRow++) {
      spacePosition[currentRow] &#x3D; [];

      for (var currentBrick &#x3D; 0; currentBrick &lt; wall[currentRow].length - 1; currentBrick++) {
        spacePosition[currentRow][currentBrick] &#x3D; wall[currentRow][currentBrick];
        spacePosition[currentRow][currentBrick] +&#x3D; spacePosition[currentRow][currentBrick - 1] || 0;

        var position &#x3D; spacePosition[currentRow][currentBrick];
        spaceCount[position] &#x3D; (spaceCount[position] || 0) + 1;

        if (cutPosition &#x3D;&#x3D;&#x3D; null || spaceCount[position] &gt; spaceCount[cutPosition]) {
          cutPosition &#x3D; position;
        }
      }
    }

    return {
      count: wall.length - spaceCount[cutPosition],
      position: cutPosition
    }
  }

  challenge.v2 &#x3D; {
    cut: cut
  };

})((window.challenge &#x3D; window.challenge || {}));
</code></pre>
        </div>
      </div>
    </div>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
    <script src="challenge/v1.js"></script>
    <script src="challenge/v2.js"></script>
    <script src="app.js"></script>
  </body>
</html>
